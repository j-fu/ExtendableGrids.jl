var documenterSearchIndex = {"docs":
[{"location":"simplexgrid/#Simplex-grid-constructors","page":"Simplex grid constructors","title":"Simplex grid constructors","text":"","category":"section"},{"location":"simplexgrid/","page":"Simplex grid constructors","title":"Simplex grid constructors","text":"Constructors for simplex grids","category":"page"},{"location":"simplexgrid/#API","page":"Simplex grid constructors","title":"API","text":"","category":"section"},{"location":"simplexgrid/","page":"Simplex grid constructors","title":"Simplex grid constructors","text":"Modules = [ExtendableGrids]\nPages = [\"simplexgrid.jl\"]","category":"page"},{"location":"simplexgrid/#ExtendableGrids.geomspace-Union{Tuple{Tv}, NTuple{4,Tv}} where Tv","page":"Simplex grid constructors","title":"ExtendableGrids.geomspace","text":"geomspace(a::Tv, b::Tv, ha::Tv, hb::Tv; tol) -> Any\n\n\n(Try to) create a subdivision of interval (a,b) stored in the  returned array X such that \n\nX[1]==a, X[end]==b\n(X[2]-X[1])<=ha+tol*(b-a)\n(X[end]-X[end-1])<=hb+tol*(b-a)\nThere is a number q such that  X[i+1]-X[i] == q*(X[i]-X[i-1])\nX is the array with the minimal possible number of points with the above property\n\nCaveat: the algorithm behind this is  well tested but unproven.\n\nReturns an Array containing the points of the subdivision.\n\n\n\n\n\n","category":"method"},{"location":"simplexgrid/#ExtendableGrids.glue-Union{Tuple{Tv}, Tuple{Array{Tv,1},Array{Tv,1}}} where Tv","page":"Simplex grid constructors","title":"ExtendableGrids.glue","text":"glue(a::Array{Tv,1}, b::Array{Tv,1}; tol) -> Array{_A,1} where _A\n\n\nGlue together two vectors a and b resulting in a vector c. They last element  of a shall be equal (up to tol) to the first element of b. The result fulfills length(c)=length(a)+length(b)-1\n\n\n\n\n\n","category":"method"},{"location":"simplexgrid/#ExtendableGrids.simplexgrid-Tuple{String,Triangulate.TriangulateIO}","page":"Simplex grid constructors","title":"ExtendableGrids.simplexgrid","text":"simplexgrid(flags::String, input::Triangulate.TriangulateIO) -> ExtendableGrid{Float64,Int32}\n\n\nCreate Grid from Triangle input data.\n\n\n\n\n\n","category":"method"},{"location":"simplexgrid/#ExtendableGrids.simplexgrid-Tuple{Type{#s13} where #s13<:IOStream}","page":"Simplex grid constructors","title":"ExtendableGrids.simplexgrid","text":"simplexgrid(::Type{#s13} where #s13<:IOStream; file, format) -> ExtendableGrid{Float64,Int32}\n\n\nRead grid from file. Currently for pdelib sg format only\n\n\n\n\n\n","category":"method"},{"location":"simplexgrid/#ExtendableGrids.simplexgrid-Tuple{}","page":"Simplex grid constructors","title":"ExtendableGrids.simplexgrid","text":"function simplexgrid(;flags::String=\"pAaqDQ\",\n                     points=Array{Cdouble,2}(undef,0,0),\n                     bfaces=Array{Cint,2}(undef,0,0),\n                     bfaceregions=Array{Cint,1}(undef,0),\n                     regionpoints=Array{Cdouble,2}(undef,0,0),\n                     regionnumbers=Array{Cint,1}(undef,0),\n                     regionvolumes=Array{Cdouble,1}(undef,0)\n                  )\n\nCreate Grid from a number of input arrays. The 2D input arrays are transposed if necessary and converted to the proper data types for Triangulate.\n\nThis conversion is not performed if the data types are thos indicated in the defaults and the leading dimension of 2D arrays corresponds to the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"simplexgrid/#ExtendableGrids.simplexgrid-Union{Tuple{AbstractArray{Tc,1}}, Tuple{Tc}} where Tc","page":"Simplex grid constructors","title":"ExtendableGrids.simplexgrid","text":"Constructor for 1D grid.\n\nConstruct 1D grid from an array of node cordinates. It creates two boundary regions with index 1 at the left end and index 2 at the right end.\n\nPrimal grid holding unknowns: marked by o, dual grid marking control volumes: marked by |.\n\n o-----o-----o-----o-----o-----o-----o-----o-----o\n |--|-----|-----|-----|-----|-----|-----|-----|--|\n\n\n\n\n\n","category":"method"},{"location":"simplexgrid/#ExtendableGrids.simplexgrid-Union{Tuple{Tc}, Tuple{AbstractArray{Tc,1},AbstractArray{Tc,1}}} where Tc","page":"Simplex grid constructors","title":"ExtendableGrids.simplexgrid","text":"simplexgrid(X::AbstractArray{Tc,1}, Y::AbstractArray{Tc,1}) -> ExtendableGrid{_A,Int32} where _A\n\n\nConstructor for 2D grid from coordinate arrays.  Boundary region numbers count counterclockwise:\n\nlocation number\nsouth 1\neast 2\nnorth 3\nwest 4\n\n\n\n\n\n","category":"method"},{"location":"simplexgrid/#ExtendableGrids.simplexgrid-Union{Tuple{Ti}, Tuple{Tc}, Tuple{Array{Tc,2},Array{Ti,2},Array{Ti,1},Array{Ti,2},Array{Ti,1}}} where Ti where Tc","page":"Simplex grid constructors","title":"ExtendableGrids.simplexgrid","text":"function simplexgrid(coord::Array{Tc,2},\n                     cellnodes::Array{Ti,2},\n                     cellregions::Array{Ti,1},\n                     bfacenodes::Array{Ti,2},\n                     bfaceregions::Array{Ti,1}\n                     ) where {Tc,Ti}\n\nCreate simplex grid from five arrays.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"allindex/#Types-and-Constructors","page":"Index","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:type]","category":"page"},{"location":"allindex/#Constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:constant]","category":"page"},{"location":"allindex/#Methods","page":"Index","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:function]","category":"page"},{"location":"adjacency/#Adjacency","page":"Adjacency","title":"Adjacency","text":"","category":"section"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"This handles adjacency matrices between entities of polyhedral complexes, e.g. nodes, cells, edges etc.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"An adjacency is described by an Adjacency matrix, which is a sparse matrix whose entries a 0 or 1. While such a matrix always can be stored as a SparseMatrixCSC, in general this would be a waste of storage.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"For the general case, it is sufficient to only store the column start indieces and the column entries (row numbers), and to implicitely assume that nonzero entries are 1. This kind of storage is realised in a VariableTargetAdjacency.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"In many cases, this can be compressed even more, if each column has the same length. In that case, a Matrix is sufficient to store the data. This is the usual base for implementing FEM/FVM assembly, and the interface for the general case should be similar.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"From these ideas we develop the following interface for an adjacency a.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"In order to avoid name confusion, we introduce the following notation which  should be consistent with the use in assembly loops.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"source:  source of adjacency link target:  target of adjacency link","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"E.g. the cell-node adjacency for FEM assembly links  a number of cells with a collection of nodes.  The cells are the sources, and the targets are the nodes. ","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"getindex(a,i,isource) aka a[i,isource]: return i-th target of  source j    numsources(a): overall number of sources, e.g. number of cells    numtargets(a): overall number of targets    numtargets(a,isource): number of targets for source given by isource    numlinks(a): number of links aka nonzero entries of adjacency matrix    show(a): print stuff","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Further API ideas:","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Convert between Matrix and Variable target stuff using 0 entries as \"padding\"","category":"page"},{"location":"adjacency/#API","page":"Adjacency","title":"API","text":"","category":"section"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Modules = [ExtendableGrids]\nPages = [\"adjacency.jl\"]","category":"page"},{"location":"adjacency/#ExtendableGrids.Adjacency","page":"Adjacency","title":"ExtendableGrids.Adjacency","text":"Adjacency type as union of FixedTargetAdjacency and VariableTargetAdjacency\n\n\n\n\n\n","category":"constant"},{"location":"adjacency/#ExtendableGrids.Adjacency-Union{Tuple{Array{T,2}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.Adjacency","text":"Constructors for Adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.FixedTargetAdjacency","page":"Adjacency","title":"ExtendableGrids.FixedTargetAdjacency","text":"mutable struct Array{T, 2} <: DenseArray{T,2}\n\nUse Matrix to store fixed target adjacency\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"struct VariableTargetAdjacency{T}\n\nAdjacency struct. Essentially, this is the sparsity pattern of a matrix whose nonzero elements all have the same value in the CSC format.\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Tuple{}","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency() -> VariableTargetAdjacency{Int64}\n\n\nCreate an empty VariableTargetAdjacency with default type\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{Array{T,2}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"Create a VariableTargetAdjacency from Matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"Create an empty VariableTargetAdjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.:==-Union{Tuple{Tb}, Tuple{Ta}, Tuple{VariableTargetAdjacency{Ta},VariableTargetAdjacency{Tb}}} where Tb where Ta","page":"Adjacency","title":"Base.:==","text":"==(a, b)\n\n\nComparison of two adjacencies\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.append!-Tuple{VariableTargetAdjacency,Any}","page":"Adjacency","title":"Base.append!","text":"append!(adj::VariableTargetAdjacency, column::Any) -> Array{T,1} where T\n\n\nAppend a column to adjacency.\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.getindex-Tuple{VariableTargetAdjacency,Any,Any}","page":"Adjacency","title":"Base.getindex","text":"getindex(adj::VariableTargetAdjacency, i::Any, isource::Any) -> Any\n\n\nAccess adjacency as if it is a 2D Array\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.show-Tuple{IO,VariableTargetAdjacency}","page":"Adjacency","title":"Base.show","text":"show(io::IO, adj::VariableTargetAdjacency)\n\n\nShow adjacency (in trasposed form; preliminary)\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.atranspose-Union{Tuple{Union{Array{T,2}, VariableTargetAdjacency{T}}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.atranspose","text":"Transpose adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{Array{T,2} where T}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(adj::Array{T,2} where T) -> Int64\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(adj::VariableTargetAdjacency) -> Any\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_links-Tuple{Array{T,2} where T}","page":"Adjacency","title":"ExtendableGrids.num_links","text":"num_links(adj::Array{T,2} where T) -> Int64\n\n\nNumber of entries\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_links-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_links","text":"num_links(adj::VariableTargetAdjacency) -> Int64\n\n\nNumber of links\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{Array{T,2} where T}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::Array{T,2} where T) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::VariableTargetAdjacency) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{Array{T,2} where T,Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::Array{T,2} where T, isource::Any) -> Int64\n\n\nNumber of targets per source if adjacency is a matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{Array{T,2} where T}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::Array{T,2} where T) -> Any\n\n\nOverall number of targets \n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{VariableTargetAdjacency,Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::VariableTargetAdjacency, isource::Any) -> Any\n\n\nNumber of targets for given source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::VariableTargetAdjacency) -> Any\n\n\nNumber of targeta\n\n\n\n\n\n","category":"method"},{"location":"plot/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"Provide plotting facilities for various Julia graphics APIs. A graphics API (Plots, PyPlot, VTKView) needs to be passed to plot in the Plotter keyword parameter","category":"page"},{"location":"plot/#API","page":"Plotting","title":"API","text":"","category":"section"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"Modules = [ExtendableGrids]\nPages = [\"plot.jl\"]","category":"page"},{"location":"plot/#ExtendableGrids.frgb-Tuple{Any,Any,Any}","page":"Plotting","title":"ExtendableGrids.frgb","text":"frgb(Plotter::Any, i::Any, max::Any; pastel) -> Any\n\n\nColor scale for grid colors.\n\n\n\n\n\n","category":"method"},{"location":"plot/#ExtendableGrids.isplots-Tuple{Any}","page":"Plotting","title":"ExtendableGrids.isplots","text":"isplots(Plotter::Any) -> Bool\n\n\nCheck if Plotter is Plots\n\n\n\n\n\n","category":"method"},{"location":"plot/#ExtendableGrids.ispyplot-Tuple{Any}","page":"Plotting","title":"ExtendableGrids.ispyplot","text":"ispyplot(Plotter::Any) -> Bool\n\n\nCheck if Plotter is PyPlot\n\n\n\n\n\n","category":"method"},{"location":"plot/#ExtendableGrids.isvtkview-Tuple{Any}","page":"Plotting","title":"ExtendableGrids.isvtkview","text":"isvtkview(Plotter::Any) -> Bool\n\n\nCheck if Plotter is VTKView\n\n\n\n\n\n","category":"method"},{"location":"plot/#ExtendableGrids.plot-Tuple{ExtendableGrid,AbstractArray{T,1} where T}","page":"Plotting","title":"ExtendableGrids.plot","text":"plot(grid::ExtendableGrid, U::AbstractArray{T,1} where T; Plotter, color, cmap, label, colorlevels, isolines, aspect, clear, show, cbar, p)\n\n\nPlot lowest order continuous finite element function on grid defined by values on the grid nodes.\n\nKeyword arguments:\n\nPlotter: defaults to nothing and can be PyPLot, Plots, VTKView.\ncolor:  color of plot on 1D grid\ncmap:  color map for heatmap plot\nlabel: label of plot\nlevels: number of isolevels\naspect: aspect ratio of plot\nclear: if true (default) clear plot before plotting\nshow: if true (default) show plot\n\n\n\n\n\n","category":"method"},{"location":"plot/#ExtendableGrids.plot-Tuple{ExtendableGrid}","page":"Plotting","title":"ExtendableGrids.plot","text":"plot(grid::ExtendableGrid; Plotter, aspect, clear, show, p)\n\n\nPlot grid. \n\nPlotter defaults to nothing and can be PyPLot, Plots, VTKView.\n\n\n\n\n\n","category":"method"},{"location":"plot/#ExtendableGrids.rectdata-Tuple{Any,Any}","page":"Plotting","title":"ExtendableGrids.rectdata","text":"rectdata(grid::Any, U::Any) -> Tuple\n\n\nReturn rectangular grid data + function to be splatted into Plots calls\n\n\n\n\n\n","category":"method"},{"location":"plot/#ExtendableGrids.tridata-Tuple{Any}","page":"Plotting","title":"ExtendableGrids.tridata","text":"tridata(grid::Any) -> Tuple{Any,Any,Any}\n\n\nReturn tridata to be splatted to PyPlot calls\n\n\n\n\n\n","category":"method"},{"location":"tdict/#The-TDict-interface-pattern","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Here we describe the idea behind the data structure used in this package. TDict means: extendable containers with type stable content access and lazy content creation via the Julia type system.","category":"page"},{"location":"tdict/#Problem-to-be-addressed","page":"The TDict interface pattern","title":"Problem to be addressed","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"In certain contexts it is desirable to use containers with core components which are user extendable and allow for type stable component acces. Moreover, some components are necessary on demand only, so they should be created lazily. Furthermore, there should be a kind of safety protocol which prevents errors from typos in component names etc.","category":"page"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Julia default data structures do not provide these properties.","category":"page"},{"location":"tdict/#struct","page":"The TDict interface pattern","title":"struct","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Julia structs with proper field type annotations guarantee type stability\nJulia structs are not extendable, fields and their types are fixed upon definition\nIf we don't fix types of struct fields they become Any and a source  for type instability\nThe situation could be fixed if getfield could be overloaded but it cant't","category":"page"},{"location":"tdict/#Dict","page":"The TDict interface pattern","title":"Dict","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Plain Dicts with flexible value types are a source of type instability\nTypical use of Dicts with strings as keys needs a meta protocol to handle semantics of keys which at the end probably hinges on string comparison which will make things slow\nSame for the implementation of a lazy evaluation protocol","category":"page"},{"location":"tdict/#Proposed-solution:","page":"The TDict interface pattern","title":"Proposed solution:","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Harness the power of the Julia type system: ","category":"page"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Use a struct containing a  Dict with DataType as keys. Every key is a type.\nUse the type system to dispatch between  getindex/setindex! methods for keys\nUse type hierarchies to manage different different value classes\nExtension requires declaring new types, keys can be only existing types almost removing typos as sources for errors\nLazy extension is managed bye an  instantiate method called by getindex if necessary\nComponent access is made type stable by type dependent getindex methods\nComponent insertion is made safe by having  setindex!  calling a veryform method","category":"page"},{"location":"tdict/#Pros","page":"The TDict interface pattern","title":"Pros","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"See above ...","category":"page"},{"location":"tdict/#Cons","page":"The TDict interface pattern","title":"Cons","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Implemented using a Dict, so access is inherently slower than access to a component of a struct. Therefore it is not well suited for inner loops.","category":"page"},{"location":"extendablegrid/#Extendable-grid","page":"Extendable grid","title":"Extendable grid","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"An ExtendableGrid in form of a dictionary with types as keys and type stable value access. This means that grid components are accessed as dict entries, e.g. grid[Coordinates] . The rationale of this approach is explained here.","category":"page"},{"location":"extendablegrid/#Notations","page":"Extendable grid","title":"Notations","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"A grid is assumed to be a subset of components of a polyhedral complex in d-dimensional space. We distinguish the following element classes characterized by their dimension:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Element class Meaning\nNode 0-dimensional node\nEdge 1-dimensional line connecting two neigboring nodes\nFace codimension 1 object separating a cell from outer space or neigboring cell\nCell codimension 0 object\nBFace Face situated at inner or domain boundary\nRegion number to be used to characterize subdomains, contacts etc.","category":"page"},{"location":"extendablegrid/#Grid-components","page":"Extendable grid","title":"Grid components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Grid components are accessed like Dict entries, the keys must be subtypes of AbstractGridComponent.","category":"page"},{"location":"extendablegrid/#Basic-set-of-grid-components","page":"Extendable grid","title":"Basic set of grid components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Upon construction, an ExtendableGrid needs to be provided with the basic set of grid components denoted by the following component type keys:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Component type key Meaning\nCoordinates Coordinates of the vertices of the grid cells\nCellNodes Adjacency describing the nodes of grid cell\nCellGeometries Abstract array of subtypes of AbstractElementGeometry describing the geometry of each cell\nCellRegions Abstract array of integers describing region numbers\nBFaceNodes Adjacency structure describing the nodes corresponding to each grid boundary face\nBFaceGeometries Abstract array of subtypes of AbstractElementGeometry describing the geometry of each boundary face\nBFaceRegions Abstract array of integers describig region numbers\nCoordinateSystem Abstract type describing the coordinate system to be used","category":"page"},{"location":"extendablegrid/#Hierarchy-of-component-type-keys","page":"Extendable grid","title":"Hierarchy of component type keys","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"The list of components can be printed using the gridcomponents method.","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\ngridcomponents() #hide","category":"page"},{"location":"extendablegrid/#Additional-components","page":"Extendable grid","title":"Additional components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Additional components can be added by defining  a subtype of AbstractGridComponent or a fitting subtype thereof, and assigning the value to the corresponding Dict entry:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\ng=simplexgrid([1,2,3,4.0])\nabstract type MyComponent <: AbstractGridComponent end\ng[MyComponent]=13\nshow(g)","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Alternatively, component creation can be perfomed lazily. For this purpose one needs to define an instantiate method:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\nabstract type NodeCells <: AbstractGridAdjacency end\nExtendableGrids.instantiate(grid, ::Type{NodeCells})=atranspose(grid[CellNodes])\ng=simplexgrid([1,2,3,4.0])\nshow(g[NodeCells])","category":"page"},{"location":"extendablegrid/#Grid-API","page":"Extendable grid","title":"Grid API","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Modules = [ExtendableGrids]\nPages = [\"extendablegrid.jl\"]","category":"page"},{"location":"extendablegrid/#ExtendableGrids.ElementInfo","page":"Extendable grid","title":"ExtendableGrids.ElementInfo","text":"const ElementInfo{T}=Union{Vector{T},VectorOfConstants{T}}`\n\nUnion type for element information arrays. If all elements have the same information, it can be stored in an economical form as a VectorOfConstants.\n\n\n\n\n\n","category":"constant"},{"location":"extendablegrid/#ExtendableGrids.AbstractElementGeometries","page":"Extendable grid","title":"ExtendableGrids.AbstractElementGeometries","text":"abstract type AbstractElementGeometries <: AbstractGridComponent\n\nArray of element geometry information. \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractElementRegions","page":"Extendable grid","title":"ExtendableGrids.AbstractElementRegions","text":"abstract type AbstractElementRegions <: AbstractGridComponent\n\nArray of element region number information. \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridAdjacency","page":"Extendable grid","title":"ExtendableGrids.AbstractGridAdjacency","text":"abstract type AbstractGridAdjacency <: AbstractGridComponent\n\nAny kind of adjacency between grid components\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridComponent","page":"Extendable grid","title":"ExtendableGrids.AbstractGridComponent","text":"abstract type AbstractGridComponent <: AbstractExtendableGridApexType\n\nApex type for grid components.\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatArray1D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatArray1D","text":"abstract type AbstractGridFloatArray1D <: AbstractGridComponent\n\n1D Array of floating point data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatArray2D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatArray2D","text":"abstract type AbstractGridFloatArray2D <: AbstractGridComponent\n\n2D Array of floating point data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatConstant","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatConstant","text":"abstract type AbstractGridFloatConstant <: AbstractGridComponent\n\nFloating point number\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerArray1D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerArray1D","text":"abstract type AbstractGridIntegerArray1D <: AbstractGridComponent\n\n1D Array of interger data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerArray2D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerArray2D","text":"abstract type AbstractGridIntegerArray2D <: AbstractGridComponent\n\n2D Array of integer data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerConstant","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerConstant","text":"abstract type AbstractGridIntegerConstant <: AbstractGridComponent\n\nInteger number\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceGeometries","page":"Extendable grid","title":"ExtendableGrids.BFaceGeometries","text":"Description of boundary face geometries\n\nabstract type BFaceGeometries <: AbstractElementGeometries\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceNodes","page":"Extendable grid","title":"ExtendableGrids.BFaceNodes","text":"abstract type BFaceNodes <: AbstractGridAdjacency\n\nAdjacency describing nodes per grid boundary face\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceRegions","page":"Extendable grid","title":"ExtendableGrids.BFaceRegions","text":"abstract type BFaceRegions <: AbstractElementRegions\n\nBoundary region number per boundary face\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellGeometries","page":"Extendable grid","title":"ExtendableGrids.CellGeometries","text":"abstract type CellGeometries <: AbstractElementGeometries\n\nDescription of cell geometries\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellNodes","page":"Extendable grid","title":"ExtendableGrids.CellNodes","text":"abstract type CellNodes <: AbstractGridAdjacency\n\nAdjacency describing nodes per grid cell\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellRegions","page":"Extendable grid","title":"ExtendableGrids.CellRegions","text":"abstract type CellRegions <: AbstractElementRegions\n\nCell region number per cell\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CoordinateSystem","page":"Extendable grid","title":"ExtendableGrids.CoordinateSystem","text":"abstract type CoordinateSystem <: AbstractGridComponent\n\nCoordinate system\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.Coordinates","page":"Extendable grid","title":"ExtendableGrids.Coordinates","text":"abstract type Coordinates <: AbstractGridFloatArray2D\n\nNode coordinates\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.ExtendableGrid","page":"Extendable grid","title":"ExtendableGrids.ExtendableGrid","text":"mutable struct ExtendableGrid{Tc, Ti}\n\nGrid type wrapping Dict\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumBFaceRegions","page":"Extendable grid","title":"ExtendableGrids.NumBFaceRegions","text":"abstract type NumBFaceRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of boundary face regions \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumCellRegions","page":"Extendable grid","title":"ExtendableGrids.NumCellRegions","text":"abstract type NumCellRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of cell regions\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#Base.get!-Tuple{ExtendableGrid,Type{#s15} where #s15<:AbstractGridComponent}","page":"Extendable grid","title":"Base.get!","text":"get!(grid::ExtendableGrid, T::Type{#s15} where #s15<:AbstractGridComponent) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing gridcomponents\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Tuple{ExtendableGrid,Type{#s15} where #s15<:AbstractGridComponent}","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid,T::Type{<:AbstractGridComponent})\n\nGeneric method for obtaining grid component.\n\nThis method is mutating in the sense that non-existing grid components are created on demand.\n\nDue to the fact that components are stored as Any the return value triggers type instability.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Type{#s15} where #s15<:AbstractElementGeometries}} where Ti where Tc","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid{Tc,Ti},T::Type{<:AbstractElementGeometries})::ElementInfo{DataType}\n\nType stable method to obtain  element type\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Type{#s15} where #s15<:AbstractElementRegions}} where Ti where Tc","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid{Tc,Ti},T::Type{<:AbstractElementRegions})::ElementInfo{Ti} where{Tc,Ti}\n\nType stable method to obtain element region number\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Type{#s15} where #s15<:AbstractGridAdjacency}} where Ti where Tc","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid{Tc,Ti},T::Type{<:AbstractGridAdjacency})::Adjacency{Ti} where{Tc,Ti}\n\nType stable return of adjacency component\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Type{#s15} where #s15<:AbstractGridFloatArray1D}} where Ti where Tc","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid{Tc,Ti},T::Type{<:AbstractGridFloatArray1D})::Array{Tc,1} where{Tc,Ti}\n\nType stable method to obtain 1D array from grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Type{#s15} where #s15<:AbstractGridFloatArray2D}} where Ti where Tc","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid{Tc,Ti},T::Type{<:AbstractGridFloatArray2D})::Array{Tc,2} \n\nType stable c method to obtain 2D array from grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Type{#s15} where #s15<:ExtendableGrids.AbstractGridFloatConstant}} where Ti where Tc","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid{Tc,Ti},T::Type{<:AbstractGridFloatConstant})::Tc where{Tc,Ti}\n\nType stable  method to obtain float constant stored on elements\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Type{#s15} where #s15<:ExtendableGrids.AbstractGridIntegerConstant}} where Ti where Tc","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid{Tc,Ti},T::Type{<:AbstractGridIntegerConstant})::Ti where{Tc,Ti}\n\nType stable method to obtain  integer constant stored on elements\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.haskey-Tuple{ExtendableGrid,Any}","page":"Extendable grid","title":"Base.haskey","text":"haskey(g::ExtendableGrid, k::Any) -> Bool\n\n\nCheck if key is in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.keys-Tuple{ExtendableGrid}","page":"Extendable grid","title":"Base.keys","text":"keys(g::ExtendableGrid) -> Base.KeySet{Type{#s16} where #s16<:AbstractGridComponent,Dict{Type{#s16} where #s16<:AbstractGridComponent,Any}}\n\n\nKeys in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.setindex!-Tuple{ExtendableGrid,Any,Type{#s15} where #s15<:AbstractGridComponent}","page":"Extendable grid","title":"Base.setindex!","text":"setindex!(grid::ExtendableGrid, v::Any, T::Type{#s15} where #s15<:AbstractGridComponent) -> Any\n\n\nSet new grid component\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.coord_type-Union{Tuple{ExtendableGrid{Tc,Ti}}, Tuple{Ti}, Tuple{Tc}} where Ti where Tc","page":"Extendable grid","title":"ExtendableGrids.coord_type","text":"Type of coordinates in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.dim_grid-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.dim_grid","text":"dim_grid(grid)\n\n\nGrid dimension dimension of grid (larges element dimension)\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.dim_space-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.dim_space","text":"dim_space(grid)\n\n\nSpace dimension of grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.gridcomponents-Tuple{}","page":"Extendable grid","title":"ExtendableGrids.gridcomponents","text":"gridcomponents()\n\n\nPrint the hierarchy of grid component key types (subtypes of AbstractGridComponent.  This includes additionally user defined subptypes.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.index_type-Union{Tuple{ExtendableGrid{Tc,Ti}}, Tuple{Ti}, Tuple{Tc}} where Ti where Tc","page":"Extendable grid","title":"ExtendableGrids.index_type","text":"index_type(grid)\n\n\nType of indices\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"\"Hook\" for methods instantiating lazy components. \n\n\n\n\n\n","category":"function"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any,Type{NumBFaceRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid::Any, _::Type{NumBFaceRegions}) -> Any\n\n\nInstantiate number of bface regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any,Type{NumCellRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid::Any, _::Type{NumCellRegions}) -> Any\n\n\nInstantiate number of cell regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.map-Tuple{Function,ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.map","text":"map(f::Function, grid::ExtendableGrid)\n\n\nMap a function onto node coordinates of grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bfaceregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bfaceregions","text":"num_bfaceregions(grid::ExtendableGrid) -> Any\n\n\nMaximum  boundary face region numbers\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bfaces-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bfaces","text":"num_bfaces(grid::ExtendableGrid) -> Int64\n\n\nNumber of boundary faces in grid.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_cellregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_cellregions","text":"num_cellregions(grid::ExtendableGrid) -> Any\n\n\nMaximum  cell  region number\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_cells-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_cells","text":"num_cells(grid::ExtendableGrid) -> Int64\n\n\nNumber of cells in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_edges-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_edges","text":"num_edges(grid::ExtendableGrid) -> Int64\n\n\nNumber of edges in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_nodes-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_nodes","text":"num_nodes(grid)\n\n\nNumber of nodes in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.veryform-Tuple{ExtendableGrid,Any,Type{#s15} where #s15<:AbstractGridComponent}","page":"Extendable grid","title":"ExtendableGrids.veryform","text":"veryform(grid::ExtendableGrid, v::Any, _::Type{#s15} where #s15<:AbstractGridComponent) -> Any\n\n\nDefault veryform method.\n\n\"veryform\"  means \"verify and/or transform\"  and is called to check and possibly transform components to be added to the grid via setindex!.\n\nThe default method just passes data through.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.veryform-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc,Ti},Any,Type{#s15} where #s15<:AbstractGridAdjacency}} where Ti where Tc","page":"Extendable grid","title":"ExtendableGrids.veryform","text":"veryform(grid::ExtendableGrid{Tc,Ti},v,T::Type{<:AbstractGridAdjacency}) where{Tc,Ti}\n\nCheck proper type of adjacencies upon insertion\n\n\n\n\n\n","category":"method"},{"location":"typehierarchy/#Type-hierarchy","page":"Type hierarchy","title":"Type hierarchy","text":"","category":"section"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"The package defines a hierarchy of abstract types to handle grid compoments. The full tree is listed here:","category":"page"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"using ExtendableGrids # hide\ntypehierarchy() #hide","category":"page"},{"location":"typehierarchy/#API","page":"Type hierarchy","title":"API","text":"","category":"section"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"Modules = [ExtendableGrids]\nPages = [\"typehierarchy.jl\"]","category":"page"},{"location":"typehierarchy/#ExtendableGrids.AbstractExtendableGridApexType","page":"Type hierarchy","title":"ExtendableGrids.AbstractExtendableGridApexType","text":"abstract type AbstractExtendableGridApexType\n\nApex type of all abstract types in this hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"typehierarchy/#AbstractTrees.children-Tuple{Type}","page":"Type hierarchy","title":"AbstractTrees.children","text":"children(T::Type) -> Union{Array{Type,1}, Array{Any,1}}\n\n\nDefine children for types.\n\n\n\n\n\n","category":"method"},{"location":"typehierarchy/#ExtendableGrids.typehierarchy-Tuple{}","page":"Type hierarchy","title":"ExtendableGrids.typehierarchy","text":"typehierarchy()\n\n\nPrint complete type hierachy for ExtendableGrids\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Vector-of-constants","page":"Vector of constants","title":"Vector of constants","text":"","category":"section"},{"location":"vectorofconstants/","page":"Vector of constants","title":"Vector of constants","text":"Datatype to store vector with a constant value.","category":"page"},{"location":"vectorofconstants/#API","page":"Vector of constants","title":"API","text":"","category":"section"},{"location":"vectorofconstants/","page":"Vector of constants","title":"Vector of constants","text":"Modules = [ExtendableGrids]\nPages = [\"vectorofconstants.jl\"]","category":"page"},{"location":"vectorofconstants/#ExtendableGrids.VectorOfConstants","page":"Vector of constants","title":"ExtendableGrids.VectorOfConstants","text":"struct VectorOfConstants{T} <: AbstractArray{T,1}\n\nVector with constant value\n\n\n\n\n\n","category":"type"},{"location":"vectorofconstants/#Base.getindex-Tuple{VectorOfConstants,Any}","page":"Vector of constants","title":"Base.getindex","text":"getindex(v::VectorOfConstants, i::Any) -> Any\n\n\nAccess\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.iterate-Tuple{VectorOfConstants,Any}","page":"Vector of constants","title":"Base.iterate","text":"iterate(v::VectorOfConstants, state::Any) -> Union{Nothing, Tuple{Any,Any}}\n\n\nIterator\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.iterate-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.iterate","text":"iterate(v::VectorOfConstants) -> Tuple{Any,Int64}\n\n\nIterator\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.length-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.length","text":"length(v::VectorOfConstants) -> Int64\n\n\nLength\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.size-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.size","text":"size(v::VectorOfConstants) -> Tuple{Int64}\n\n\nSize\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.unique-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.unique","text":"unique(v::VectorOfConstants) -> Array{_A,1} where _A\n\n\nShortcut for unique\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#Element-geometry","page":"Element geometry","title":"Element geometry","text":"","category":"section"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"Element geometries are described via abstract types. The list of element geometries systems can be obtained with the elementgeometries method:","category":"page"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"using ExtendableGrids # hide\nelementgeometries() #hide","category":"page"},{"location":"elementgeometry/#API","page":"Element geometry","title":"API","text":"","category":"section"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"Modules = [ExtendableGrids]\nPages = [\"elementgeometry.jl\"]","category":"page"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry","text":"abstract type AbstractElementGeometry <: AbstractExtendableGridApexType\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry0D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry0D","text":"abstract type AbstractElementGeometry0D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry1D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry1D","text":"abstract type AbstractElementGeometry1D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry2D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry2D","text":"abstract type AbstractElementGeometry2D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry3D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry3D","text":"abstract type AbstractElementGeometry3D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry4D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry4D","text":"abstract type AbstractElementGeometry4D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Circle2D","page":"Element geometry","title":"ExtendableGrids.Circle2D","text":"abstract type Circle2D <: AbstractElementGeometry2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Edge1D","page":"Element geometry","title":"ExtendableGrids.Edge1D","text":"abstract type Edge1D <: AbstractElementGeometry1D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Hexagon2D","page":"Element geometry","title":"ExtendableGrids.Hexagon2D","text":"abstract type Hexagon2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Hexahedron3D","page":"Element geometry","title":"ExtendableGrids.Hexahedron3D","text":"abstract type Hexahedron3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.HyperCube4D","page":"Element geometry","title":"ExtendableGrids.HyperCube4D","text":"abstract type HyperCube4D <: AbstractElementGeometry4D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Parallelepiped3D","page":"Element geometry","title":"ExtendableGrids.Parallelepiped3D","text":"abstract type Parallelepiped3D <: Hexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Parallelogram2D","page":"Element geometry","title":"ExtendableGrids.Parallelogram2D","text":"abstract type Parallelogram2D <: Quadrilateral2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Pentagon2D","page":"Element geometry","title":"ExtendableGrids.Pentagon2D","text":"abstract type Pentagon2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polychoron4D","page":"Element geometry","title":"ExtendableGrids.Polychoron4D","text":"abstract type Polychoron4D <: AbstractElementGeometry4D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polygon2D","page":"Element geometry","title":"ExtendableGrids.Polygon2D","text":"abstract type Polygon2D <: AbstractElementGeometry2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polyhedron3D","page":"Element geometry","title":"ExtendableGrids.Polyhedron3D","text":"abstract type Polyhedron3D <: AbstractElementGeometry3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Prism3D","page":"Element geometry","title":"ExtendableGrids.Prism3D","text":"abstract type Prism3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Quadrilateral2D","page":"Element geometry","title":"ExtendableGrids.Quadrilateral2D","text":"abstract type Quadrilateral2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Sphere3D","page":"Element geometry","title":"ExtendableGrids.Sphere3D","text":"abstract type Sphere3D <: AbstractElementGeometry3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Tetrahedron3D","page":"Element geometry","title":"ExtendableGrids.Tetrahedron3D","text":"abstract type Tetrahedron3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Triangle2D","page":"Element geometry","title":"ExtendableGrids.Triangle2D","text":"abstract type Triangle2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.TrianglePrism3D","page":"Element geometry","title":"ExtendableGrids.TrianglePrism3D","text":"abstract type TrianglePrism3D <: Prism3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Vertex0D","page":"Element geometry","title":"ExtendableGrids.Vertex0D","text":"abstract type Vertex0D <: AbstractElementGeometry0D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{#s15} where #s15<:AbstractElementGeometry0D}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{#s15} where #s15<:AbstractElementGeometry0D) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{#s15} where #s15<:AbstractElementGeometry1D}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{#s15} where #s15<:AbstractElementGeometry1D) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{#s15} where #s15<:AbstractElementGeometry2D}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{#s15} where #s15<:AbstractElementGeometry2D) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{#s15} where #s15<:AbstractElementGeometry3D}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{#s15} where #s15<:AbstractElementGeometry3D) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{#s15} where #s15<:AbstractElementGeometry4D}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{#s15} where #s15<:AbstractElementGeometry4D) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.elementgeometries-Tuple{}","page":"Element geometry","title":"ExtendableGrids.elementgeometries","text":"elementgeometries()\n\n\nList supported element geometries.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#Token-streams","page":"Token streams","title":"Token streams","text":"","category":"section"},{"location":"tokenstream/","page":"Token streams","title":"Token streams","text":"The TokenStream struct supports reading of tokenizable ASCII files","category":"page"},{"location":"tokenstream/#API","page":"Token streams","title":"API","text":"","category":"section"},{"location":"tokenstream/","page":"Token streams","title":"Token streams","text":"Modules = [ExtendableGrids]\nPages = [\"tokenstream.jl\"]","category":"page"},{"location":"tokenstream/#ExtendableGrids.TokenStream","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"mutable struct TokenStream\n\nTokenstream allows to read tokenized data from file without keeping the file ocntent in memory.\n\ninput::IOStream\nInput stream\n\ntokens::Array{SubString{String},1}\nArray of current tokens kept in memory.\n\nitoken::Int64\nPosition of actual token in tokens array\n\nlineno::Int64\nLine number in IOStream\n\ncomment::Char\nComment character\n\ndlm::Function\nFunction telling if given character is a delimiter.\n\n\n\n\n\n","category":"type"},{"location":"tokenstream/#ExtendableGrids.TokenStream-Tuple{IOStream}","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"TokenStream(input::IOStream; comment, dlm) -> TokenStream\n\n\nCreate Tokenstream with IOStream argument.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.TokenStream-Tuple{String}","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"TokenStream(filename::String; comment, dlm) -> TokenStream\n\n\nCreate Tokenstream with file name argument.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.UnexpectedTokenError","page":"Token streams","title":"ExtendableGrids.UnexpectedTokenError","text":"struct UnexpectedTokenError <: Exception\n\nError thrown when the token expected  in expect!  is not there.\n\nfound::String\nexpected::String\nlineno::Int64\n\n\n\n\n\n","category":"type"},{"location":"tokenstream/#Base.eof-Tuple{TokenStream}","page":"Token streams","title":"Base.eof","text":"eof(tks::TokenStream) -> Bool\n\n\nCheck if all tokens have been consumed.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.destruct!-Tuple{TokenStream}","page":"Token streams","title":"ExtendableGrids.destruct!","text":"destruct!(tks::TokenStream)\n\n\nTokenstream destructor should close input\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.expecttoken-Tuple{TokenStream,String}","page":"Token streams","title":"ExtendableGrids.expecttoken","text":"expecttoken(tks::TokenStream, expected::String) -> Bool\n\n\nExpect keyword token.\n\nIf token is missing, an UnexpectedTokenError is thrown If the token  has been found, reading will continue  at the position after the token found.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.gettoken-Tuple{TokenStream}","page":"Token streams","title":"ExtendableGrids.gettoken","text":"gettoken(tks::TokenStream) -> Union{Nothing, SubString{String}}\n\n\nGet next token from tokenstream.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.trytoken-Tuple{TokenStream,String}","page":"Token streams","title":"ExtendableGrids.trytoken","text":"trytoken(tks::TokenStream, expected::String) -> Bool\n\n\nTry for keyword token.\n\nIt token is missing, the token read is put back into stream, a value of false is returned and the next try/gettoken command continues at the same position,\n\nOtherwise, true is returned, and reading continues after the token found.\n\n\n\n\n\n","category":"method"},{"location":"regionedit/#Region-editing","page":"Region editing","title":"Region editing","text":"","category":"section"},{"location":"regionedit/","page":"Region editing","title":"Region editing","text":"Tools for editing grid region numbers","category":"page"},{"location":"regionedit/#API","page":"Region editing","title":"API","text":"","category":"section"},{"location":"regionedit/","page":"Region editing","title":"Region editing","text":"Modules = [ExtendableGrids]\nPages = [\"regionedit.jl\"]","category":"page"},{"location":"regionedit/#ExtendableGrids.bfacemask!-Tuple{ExtendableGrid,AbstractArray,AbstractArray,Int64}","page":"Region editing","title":"ExtendableGrids.bfacemask!","text":"bfacemask!(grid::ExtendableGrid, maskmin::AbstractArray, maskmax::AbstractArray, ireg::Int64; tol) -> ExtendableGrid\n\n\nEdit region numbers of grid  boundary facets  via rectangular mask. For 1D grids, inner boundaries can be added by this method.\n\n\n\n\n\n","category":"method"},{"location":"regionedit/#ExtendableGrids.cellmask!-Tuple{ExtendableGrid,AbstractArray,AbstractArray,Int64}","page":"Region editing","title":"ExtendableGrids.cellmask!","text":"cellmask!(grid::ExtendableGrid, maskmin::AbstractArray, maskmax::AbstractArray, ireg::Int64; tol) -> Any\n\n\nEdit region numbers of grid cells via rectangular mask.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Subgrid","page":"Subgrid","title":"Subgrid","text":"","category":"section"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Subgrids of an ExtendableGrid are again of the same type ExtendableGrid and unse the typed Dict mechanism to store linkage to the parent grid.","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"using ExtendableGrids # hide\ngrid=simplexgrid([1,2,3], [4,5,6])\nsub=subgrid(grid,[2],boundary=true, transform=(a,b) -> (a[1]=10*b[2]))\nprintln(keys(sub))\nprintln(sub[Coordinates])","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Given a vector on the parent grid, one can create a view of this vecotor on the subgrid:","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"using ExtendableGrids # hide\ngrid=simplexgrid([1,2,3], [4,5,6])\nsub=subgrid(grid,[2],boundary=true, transform=(a,b) -> (a[1]=10*b[2]))\nv=[i for i=1:num_nodes(grid)]\nsubv=view(v,sub)\nprintln(subv)","category":"page"},{"location":"subgrid/#API","page":"Subgrid","title":"API","text":"","category":"section"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Modules = [ExtendableGrids]\nPages = [\"subgrid.jl\"]","category":"page"},{"location":"subgrid/#ExtendableGrids.NodeInParent","page":"Subgrid","title":"ExtendableGrids.NodeInParent","text":"abstract type NodeInParent <: AbstractGridIntegerArray1D\n\nGrid component key type for storing node in parent array\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.ParentGrid","page":"Subgrid","title":"ExtendableGrids.ParentGrid","text":"abstract type ParentGrid <: AbstractGridComponent\n\nGrid component key type for storing parent grid\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.SubgridVectorView","page":"Subgrid","title":"ExtendableGrids.SubgridVectorView","text":"struct SubgridVectorView{Tv, Ti} <: AbstractArray{Tv,1}\n\nVector view on subgrid\n\nsysarray::AbstractArray{Tv,1} where Tv\nnode_in_parent::Array{Ti,1} where Ti\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#Base.getindex-Tuple{ExtendableGrids.SubgridVectorView,Integer}","page":"Subgrid","title":"Base.getindex","text":"getindex(aview::ExtendableGrids.SubgridVectorView, inode::Integer) -> Any\n\n\nAccessor method for subgrid vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.setindex!-Tuple{ExtendableGrids.SubgridVectorView,Any,Integer}","page":"Subgrid","title":"Base.setindex!","text":"setindex!(aview::ExtendableGrids.SubgridVectorView, v::Any, inode::Integer) -> ExtendableGrids.SubgridVectorView\n\n\nAccessor method for subgrid vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.size-Tuple{ExtendableGrids.SubgridVectorView}","page":"Subgrid","title":"Base.size","text":"size(a::ExtendableGrids.SubgridVectorView) -> Tuple{Int64}\n\n\nReturn size of vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.view-Tuple{AbstractArray{T,1} where T,ExtendableGrid}","page":"Subgrid","title":"Base.view","text":"view(a::AbstractArray{T,1} where T, subgrid::ExtendableGrid) -> ExtendableGrids.SubgridVectorView{_A,_B} where _B where _A\n\n\nCreate a view of the vector on a subgrid.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#ExtendableGrids._copytransform!-Tuple{AbstractArray,AbstractArray}","page":"Subgrid","title":"ExtendableGrids._copytransform!","text":"_copytransform!(a::AbstractArray, b::AbstractArray)\n\n\nDefault transform for subgrid creation\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#ExtendableGrids.subgrid-Tuple{Any,AbstractArray}","page":"Subgrid","title":"ExtendableGrids.subgrid","text":"subgrid(parent::Any, subregions::AbstractArray; transform, boundary) -> ExtendableGrid{_A,_B} where _B where _A\n\n\nCreate subgrid from list of regions.\n\nparent: parent grid \nsubregions:  Array of subregions\ntransform (kw parameter): transformation function between  grid and subgrid coordinates acting on one point.  Default: copytransform\nboundary: if true, create codimension 1 subgrid from boundary region.\n\nA subgrid is of type ExtendableGrid and stores two additional components: ParentGrid and NodeInParent\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"coordinatesystem/#Coordinate-systems","page":"Coordinate systems","title":"Coordinate systems","text":"","category":"section"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"Coordinate systems are described via abstract types. The list of coordinate systems can be obtained with the coordinatesystems method:","category":"page"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"using ExtendableGrids # hide\ncoordinatesystems() #hide","category":"page"},{"location":"coordinatesystem/#API","page":"Coordinate systems","title":"API","text":"","category":"section"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"Modules = [ExtendableGrids]\nPages = [\"coordinatesystem.jl\"]","category":"page"},{"location":"coordinatesystem/#ExtendableGrids.AbstractCoordinateSystem","page":"Coordinate systems","title":"ExtendableGrids.AbstractCoordinateSystem","text":"abstract type AbstractCoordinateSystem <: AbstractExtendableGridApexType\n\nApex type for coordinate systems\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian1D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian1D","text":"abstract type Cartesian1D <: AbstractCoordinateSystem\n\n1D cartesion coordinate system (unknown x)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian2D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian2D","text":"abstract type Cartesian2D <: AbstractCoordinateSystem\n\n2D cartesion coordinate system (unknowns x,y)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian3D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian3D","text":"abstract type Cartesian3D <: AbstractCoordinateSystem\n\n2D cartesion coordinate system (unknowns x,y,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cylindrical2D","page":"Coordinate systems","title":"ExtendableGrids.Cylindrical2D","text":"abstract type Cylindrical2D <: AbstractCoordinateSystem\n\n2D cylindrical coordinate system (unknowns r,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cylindrical3D","page":"Coordinate systems","title":"ExtendableGrids.Cylindrical3D","text":"abstract type Cylindrical3D <: AbstractCoordinateSystem\n\n3D cylindrical coordinate system (unknowns r,,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Polar1D","page":"Coordinate systems","title":"ExtendableGrids.Polar1D","text":"abstract type Polar1D <: AbstractCoordinateSystem\n\n1D polar coordinate system (unknown r)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Polar2D","page":"Coordinate systems","title":"ExtendableGrids.Polar2D","text":"abstract type Polar2D <: AbstractCoordinateSystem\n\n2D polar coordinate system (unknowns r,)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Spherical1D","page":"Coordinate systems","title":"ExtendableGrids.Spherical1D","text":"abstract type Spherical1D <: AbstractCoordinateSystem\n\n1D spheriacal coordinate system (unknown r)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Spherical3D","page":"Coordinate systems","title":"ExtendableGrids.Spherical3D","text":"abstract type Spherical3D <: AbstractCoordinateSystem\n\n3D spheriacal coordinate system (unknowns r,,)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.coordinatesystems-Tuple{}","page":"Coordinate systems","title":"ExtendableGrids.coordinatesystems","text":"coordinatesystems()\n\n\nList possible coordinate systems. These describe the meaning of the grid coordinates.\n\n\n\n\n\n","category":"method"}]
}
